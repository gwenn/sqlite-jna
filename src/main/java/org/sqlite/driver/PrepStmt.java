/*
 * The author disclaims copyright to this source code.  In place of
 * a legal notice, here is a blessing:
 *
 *    May you do good and not evil.
 *    May you find forgiveness for yourself and forgive others.
 *    May you share freely, never taking more than you give.
 */
package org.sqlite.driver;

import org.checkerframework.checker.index.qual.Positive;
import org.checkerframework.checker.nullness.qual.NonNull;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.sqlite.ErrCodes;
import org.sqlite.StmtException;
import org.sqlite.ZeroBlob;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.BatchUpdateException;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Date;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLType;
import java.sql.SQLXML;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.time.LocalDate;
import java.time.temporal.Temporal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

/*
Blob Incremental I/O:
--------------------

* Initialization:

CREATE TABLE test (
-- pk   INTEGER PRIMARY KEY -- optional ROWID alias
-- ...
   data BLOB
-- ...
);
INSERT INTO test (data) VALUES (zeroblob(:blob_size));
SELECT last_insert_rowid();
-- or
UPDATE test SET data = zeroblob(:blob_size) WHERE rowid = :rowid;

* Read:

SELECT [rowid,] data FROM test [WHERE rowid = :rowid ...];
  stmt.setRowId(1, rowId); -- (1): optional if (2)
  ...
  ResultSet rs = stmt.getResultSet();

  Blob blob;
  while (rs.next()) {
    rs.getRowId(1); -- (2): mandatory if not (1)
    blob = rs.getBlob(2);
    // ...
  }
  blob.free();
  rs.close();

* Write:

UPDATE test SET data = :blob WHERE rowid = :rowid;
  smt.setRowId(2, rowId); -- mandatory, first
  smt.setBlob|setBinaryStream(1, ...);

 */
class PrepStmt extends Stmt implements ParameterMetaData, SQLitePreparedStatement {
	@Nullable
	private RowId rowId;
	@NonNull
	private Map<Integer, org.sqlite.Blob> blobByParamIndex = Collections.emptyMap();

	private boolean batching;
	@Nullable
	private Object[] bindings;
	private boolean[] bound;
	private boolean boundChecked;
	@Nullable
	private List<Object[]> batch; // list of bindings

	PrepStmt(Conn c, org.sqlite.Stmt stmt, Generated autoGeneratedKeys) {
		super(c, stmt, autoGeneratedKeys);
	}

	@Override
	@NonNull
	public ResultSet executeQuery() throws SQLException {
		org.sqlite.Stmt stmt = getStmt();
		stmt.reset();
		if (!boundChecked) {
			checkParameters(stmt);
		}
		return createRows();
	}

	@Override
	public int executeUpdate() throws SQLException {
		org.sqlite.Stmt stmt = getStmt();
		if (!boundChecked) {
			checkParameters(stmt);
		}
		step(true);
		return getConn().getChanges();
	}
	@Override
	public long executeLargeUpdate() throws SQLException {
		org.sqlite.Stmt stmt = getStmt();
		if (!boundChecked) {
			checkParameters(stmt);
		}
		step(true);
		return getConn().getChanges64();
	}

	@Override
	public void setNull(@Positive int parameterIndex, int sqlType) throws SQLException {
		bindNull(parameterIndex);
	}
	@Override
	public void setNull(@NonNull String parameterName, int sqlType) throws SQLException {
		setNull(getBindParameterIndex(parameterName), sqlType);
	}

	@Override
	public void setBoolean(@Positive int parameterIndex, boolean x) throws SQLException {
		bindInt(parameterIndex, x ? 1 : 0);
	}
	@Override
	public void setBoolean(@NonNull String parameterName, boolean x) throws SQLException {
		setBoolean(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setByte(@Positive int parameterIndex, byte x) throws SQLException {
		bindInt(parameterIndex, x);
	}
	@Override
	public void setByte(@NonNull String parameterName, byte x) throws SQLException {
		setByte(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setShort(@Positive int parameterIndex, short x) throws SQLException {
		bindInt(parameterIndex, x);
	}
	@Override
	public void setShort(@NonNull String parameterName, short x) throws SQLException {
		setShort(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setInt(@Positive int parameterIndex, int x) throws SQLException {
		bindInt(parameterIndex, x);
	}
	@Override
	public void setInt(@NonNull String parameterName, int x) throws SQLException {
		setInt(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setLong(@Positive int parameterIndex, long x) throws SQLException {
		bindLong(parameterIndex, x);
	}
	@Override
	public void setLong(@NonNull String parameterName, long x) throws SQLException {
		setLong(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setFloat(@Positive int parameterIndex, float x) throws SQLException {
		bindDouble(parameterIndex, x);
	}
	@Override
	public void setFloat(@NonNull String parameterName, float x) throws SQLException {
		setFloat(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setDouble(@Positive int parameterIndex, double x) throws SQLException {
		bindDouble(parameterIndex, x);
	}
	@Override
	public void setDouble(@NonNull String parameterName, double x) throws SQLException {
		setDouble(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setBigDecimal(@Positive int parameterIndex, @Nullable BigDecimal x) throws SQLException {
		if (x == null) {
			bindNull(parameterIndex);
		} else {
			bindText(parameterIndex, x.toString());
		}
	}
	@Override
	public void setBigDecimal(@NonNull String parameterName, @Nullable BigDecimal x) throws SQLException {
		setBigDecimal(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setString(@Positive int parameterIndex, @Nullable String x) throws SQLException {
		bindText(parameterIndex, x);
	}
	@Override
	public void setString(@NonNull String parameterName, @Nullable String x) throws SQLException {
		setString(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setBytes(@Positive int parameterIndex, byte @Nullable [] x) throws SQLException {
		if (x == null) {
			bindNull(parameterIndex);
		} else {
			bindBlob(parameterIndex, x);
		}
	}
	@Override
	public void setBytes(@NonNull String parameterName, byte @Nullable [] x) throws SQLException {
		setBytes(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setDate(@Positive int parameterIndex, @Nullable Date x) throws SQLException {
		bindDate(parameterIndex, x, DateUtil.DATE_CONFIG);
	}
	@Override
	public void setDate(@NonNull String parameterName, @Nullable Date x) throws SQLException {
		setDate(getBindParameterIndex(parameterName), x);
	}

	private void bindDate(@Positive int parameterIndex, java.util.@Nullable Date x, int cfgIdx) throws SQLException {
		if (null == x) {
			bindNull(parameterIndex);
		} else {
			String fmt = conn().dateTimeConfig[cfgIdx];
			boolean sqlDate = cfgIdx == DateUtil.DATE_CONFIG;
			if (sqlDate && DateUtil.EPOCH_DAY.equals(fmt)) {
				bindLong(parameterIndex, ((java.sql.Date)x).toLocalDate().toEpochDay());
			} else if (fmt == null || DateUtil.UNIXEPOCH.equals(fmt)) {
				bindLong(parameterIndex, sqlDate ? DateUtil.normalizeDate(x.getTime(), null) : x.getTime());
			} else if (DateUtil.JULIANDAY.equals(fmt)) {
				long unixepoch = sqlDate ? DateUtil.normalizeDate(x.getTime(), null) : x.getTime();
				bindDouble(parameterIndex, DateUtil.toJulianDay(unixepoch));
			} else {
				bindText(parameterIndex, DateUtil.formatDate(x, fmt, null));
			}
		}
	}

	@Override
	public void setTime(@Positive int parameterIndex, @Nullable Time x) throws SQLException {
		bindDate(parameterIndex, x, DateUtil.TIME_CONFIG);
	}
	@Override
	public void setTime(@NonNull String parameterName, @Nullable Time x) throws SQLException {
		setTime(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setTimestamp(@Positive int parameterIndex, @Nullable Timestamp x) throws SQLException {
		bindDate(parameterIndex, x, DateUtil.TIMESTAMP_CONFIG);
	}
	@Override
	public void setTimestamp(@NonNull String parameterName, @Nullable Timestamp x) throws SQLException {
		setTimestamp(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException {
		throw Util.unsupported("PreparedStatement.setAsciiStream");
	}
	@Override
	public void setAsciiStream(@NonNull String parameterName, InputStream x, int length) throws SQLException {
		setAsciiStream(getBindParameterIndex(parameterName), x, length);
	}

	@Override
	@SuppressWarnings("deprecation")
	public void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException {
		throw Util.unsupported("PreparedStatement.setUnicodeStream");
	}

	@Override
	public void setBinaryStream(@Positive int parameterIndex, @Nullable InputStream x, int length) throws SQLException {
		if (x == null) {
			bindNull(parameterIndex);
		}
		if (rowId == null) { // No streaming mode...
			// throw new SQLException("You must set the associated RowId before opening a Blob");
			ByteArrayOutputStream output = new ByteArrayOutputStream();
			try {
				org.sqlite.Blob.copy(x, output, length);
			} catch (IOException e) {
				throw new SQLException("Error while reading binary stream", e);
			}
			setBytes(parameterIndex, output.toByteArray());
			return;
		}
		org.sqlite.Blob blob = blobByParamIndex.get(parameterIndex);
		if (blob == null || blob.isClosed()) {
			blob = getStmt().open(parameterIndex, RowIdImpl.getValue(rowId), true); // FIXME getColumnOriginName can be called only with SELECT...
			if (blob != null) {
				if (blobByParamIndex.isEmpty() && !(blobByParamIndex instanceof TreeMap)) {
					blobByParamIndex = new TreeMap<>();
				}
				blobByParamIndex.put(parameterIndex, blob);
			} else {
				throw new SQLException("No Blob!"); // TODO improve message
			}
		} else {
			blob.reopen(RowIdImpl.getValue(rowId));
		}

		// The data will be read from the stream as needed until end-of-file is reached.
		try {
			org.sqlite.Blob.copy(x, blob.getOutputStream(), length);
		} catch (IOException e) {
			throw new SQLException("Error while reading binary stream", e);
		} finally {
			blob.close();
		}
		bound[parameterIndex - 1] = true;
	}
	@Override
	public void setBinaryStream(@NonNull String parameterName, @Nullable InputStream x, int length) throws SQLException {
		setBinaryStream(getBindParameterIndex(parameterName), x, length);
	}

	@Override
	public void clearParameters() throws SQLException {
		getStmt().clearBindings();
		if (bindings != null) {
			Arrays.fill(bindings, null);
			Arrays.fill(bound, false);
			boundChecked = false;
			rowId = null;
		}
	}

	@Override
	public void setObject(@Positive int parameterIndex, @Nullable Object x, int targetSqlType) throws SQLException {
		setObject(parameterIndex, x, targetSqlType, 0);
	}
	@Override
	public void setObject(@Positive int parameterIndex, @Nullable Object x, @NonNull SQLType targetSqlType) throws SQLException {
		setObject(parameterIndex, x, targetSqlType, 0);
	}

	@Override
	public void setObject(@NonNull String parameterName, @Nullable Object x, int targetSqlType) throws SQLException {
		setObject(getBindParameterIndex(parameterName), x, targetSqlType);
	}
	@Override
	public void setObject(@NonNull String parameterName, @Nullable Object x, @NonNull SQLType targetSqlType) throws SQLException {
		setObject(getBindParameterIndex(parameterName), x, targetSqlType);
	}

	@Override
	public void setObject(@Positive int parameterIndex, @Nullable Object x) throws SQLException {
		switch (x) {
			case null -> bindNull(parameterIndex);
			case String s -> setString(parameterIndex, s);
			case Boolean b -> setBoolean(parameterIndex, b);
			case Integer i -> setInt(parameterIndex, i);
			case Long l -> setLong(parameterIndex, l);
			case Float v -> setFloat(parameterIndex, v);
			case Double v -> setDouble(parameterIndex, v);
			case Date date -> setDate(parameterIndex, date);
			case Time time -> setTime(parameterIndex, time);
			case Timestamp timestamp -> setTimestamp(parameterIndex, timestamp);
			case BigDecimal bigDecimal -> setBigDecimal(parameterIndex, bigDecimal);
			case Byte b -> setByte(parameterIndex, b);
			case Short i -> setShort(parameterIndex, i);
			case Character c -> setString(parameterIndex, c.toString());
			case byte[] bytes -> setBytes(parameterIndex, bytes);
			case ZeroBlob zeroBlob -> bindZeroBlob(parameterIndex, zeroBlob);
			case Blob blob -> setBlob(parameterIndex, blob);
			case Clob clob -> setClob(parameterIndex, clob);
			case Array array -> setArray(parameterIndex, array);
			case Temporal temporal -> setString(parameterIndex, temporal.toString());
			default ->
				throw new StmtException(getStmt(), String.format("Unsupported type: %s", x.getClass().getName()), ErrCodes.WRAPPER_SPECIFIC);
		}
	}
	@Override
	public void setObject(@NonNull String parameterName, @Nullable Object x) throws SQLException {
		setObject(getBindParameterIndex(parameterName), x);
	}

	@Override
	public boolean execute() throws SQLException {
		org.sqlite.Stmt stmt = getStmt();
		stmt.reset(); // may be reset twice but I don't see how it can be avoided
		if (!boundChecked) {
			checkParameters(stmt);
		}
		return exec();
	}

	@Override
	public void addBatch() throws SQLException {
		if (!batching) {
			batching = true;
		}
		if (batch == null) {
			batch = new ArrayList<>();
		}
		if (!boundChecked) {
			checkParameters(getStmt());
		}
		if (bindings == null) { // parameterCount == 0
			batch.add(null);
		} else {
			batch.add(Arrays.copyOf(bindings, bindings.length));
		}
	}

	@Override
	public void clearBatch() throws SQLException {
		checkOpen();
		if (batch != null) {
			batch.clear();
		}
		batching = false;
	}

	@Override
	public int @NonNull [] executeBatch() throws SQLException {
		org.sqlite.Stmt stmt = getStmt();
		batching = false;
		if (batch == null) {
			return new int[0]; // FIXME
		}
		int size = batch.size();
		SQLException cause = null;
		Object[] params;
		int[] changes = new int[size];
		for (int i = 0; i < size; ++i) {
			try {
				params = batch.get(i);
				if (params != null) {
					for (int j = 0; j < params.length; j++) {
						stmt.bindByIndex(j + 1, params[j]);
					}
				}
				changes[i] = executeUpdate();
			} catch (SQLException e) {
				if (cause != null) {
					e.setNextException(cause);
				}
				cause = e;
				changes[i] = EXECUTE_FAILED;
			}
		}
		clearBatch();
		if (cause != null) {
			throw new BatchUpdateException("batch failed", changes, cause);
		}
		return changes;
	}
	// TODO executeLargeBatch

	@Override
	public void setCharacterStream(int parameterIndex, Reader reader, int length) throws SQLException {
		throw Util.unsupported("PreparedStatement.setCharacterStream");
	}
	@Override
	public void setCharacterStream(@NonNull String parameterName, Reader reader, int length) throws SQLException {
		setCharacterStream(getBindParameterIndex(parameterName), reader, length);
	}

	@Override
	public void setRef(int parameterIndex, Ref x) throws SQLException {
		throw Util.unsupported("PreparedStatement.setRef");
	}

	@Override
	public void setBlob(@Positive int parameterIndex, @Nullable Blob x) throws SQLException {
		if (x == null) {
			bindNull(parameterIndex);
		} else {
			setBinaryStream(parameterIndex, x.getBinaryStream(), x.length());
		}
	}
	@Override
	public void setBlob(@NonNull String parameterName, @Nullable Blob x) throws SQLException {
		setBlob(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setClob(int parameterIndex, Clob x) throws SQLException {
		throw Util.unsupported("PreparedStatement.setClob");
	}
	@Override
	public void setClob(@NonNull String parameterName, Clob x) throws SQLException {
		setClob(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setArray(int parameterIndex, Array x) throws SQLException {
		throw Util.unsupported("PreparedStatement.setArray");
	}

	@Override
	@Nullable
	public ResultSetMetaData getMetaData() throws SQLException {
		org.sqlite.Stmt stmt = getStmt();
		if (stmt.getColumnCount() == 0) {
			return null;
		}
		return new RowsMeta(stmt);
	}

	@Override
	public void setDate(@Positive int parameterIndex, @Nullable Date x, @Nullable Calendar cal) throws SQLException {
		if (x == null || cal == null) {
			setDate(parameterIndex, x);
			return;
		}
		throw Util.unsupported("*PreparedStatement.setDate"); // TODO
	}
	@Override
	public void setDate(@NonNull String parameterName, @Nullable Date x, @Nullable Calendar cal) throws SQLException {
		setDate(getBindParameterIndex(parameterName), x, cal);
	}

	@Override
	public void setTime(@Positive int parameterIndex, @Nullable Time x, @Nullable Calendar cal) throws SQLException {
		if (x == null || cal == null) {
			setTime(parameterIndex, x);
			return;
		}
		throw Util.unsupported("*PreparedStatement.setTime"); // TODO
	}
	@Override
	public void setTime(@NonNull String parameterName, @Nullable Time x, @Nullable Calendar cal) throws SQLException {
		setTime(getBindParameterIndex(parameterName), x, cal);
	}

	@Override
	public void setTimestamp(@Positive int parameterIndex, @Nullable Timestamp x, @Nullable Calendar cal) throws SQLException {
		if (x == null || cal == null) {
			setTimestamp(parameterIndex, x);
		}
		throw Util.unsupported("*PreparedStatement.setTimestamp"); // TODO
	}
	@Override
	public void setTimestamp(@NonNull String parameterName, @Nullable Timestamp x, @Nullable Calendar cal) throws SQLException {
		setTimestamp(getBindParameterIndex(parameterName), x, cal);
	}

	@Override
	public void setNull(@Positive int parameterIndex, int sqlType, @Nullable String typeName) throws SQLException {
		setNull(parameterIndex, sqlType);
	}
	@Override
	public void setNull(@NonNull String parameterName, int sqlType, @Nullable String typeName) throws SQLException {
		setNull(getBindParameterIndex(parameterName), sqlType, typeName);
	}

	@Override
	public void setURL(int parameterIndex, URL x) throws SQLException {
		throw Util.unsupported("PreparedStatement.setURL");
	}
	@Override
	public void setURL(@NonNull String parameterName, URL val) throws SQLException {
		setURL(getBindParameterIndex(parameterName), val);
	}

	@Override
	@NonNull
	public ParameterMetaData getParameterMetaData() {
		return this;
	}

	@Override
	public void setRowId(@Positive int parameterIndex, @Nullable RowId x) throws SQLException {
		if (x == null) {
			bindNull(parameterIndex);
		} else {
			rowId = x;
			bindLong(parameterIndex, RowIdImpl.getValue(x));
		}
	}
	@Override
	public void setRowId(@NonNull String parameterName, @Nullable RowId x) throws SQLException {
		setRowId(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setNString(@Positive int parameterIndex, @Nullable String value) throws SQLException {
		setString(parameterIndex, value);
	}
	@Override
	public void setNString(@NonNull String parameterName, @Nullable String value) throws SQLException {
		setNString(getBindParameterIndex(parameterName), value);
	}

	@Override
	public void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException {
		throw Util.unsupported("PreparedStatement.setNCharacterStream");
	}
	@Override
	public void setNCharacterStream(@NonNull String parameterName, Reader value, long length) throws SQLException {
		setNCharacterStream(getBindParameterIndex(parameterName), value, length);
	}

	@Override
	public void setNClob(int parameterIndex, NClob value) throws SQLException {
		throw Util.unsupported("PreparedStatement.setNClob");
	}
	@Override
	public void setNClob(@NonNull String parameterName, NClob value) throws SQLException {
		setNClob(getBindParameterIndex(parameterName), value);
	}

	@Override
	public void setClob(int parameterIndex, Reader reader, long length) throws SQLException {
		throw Util.unsupported("PreparedStatement.setClob");
	}
	@Override
	public void setClob(@NonNull String parameterName, Reader reader, long length) throws SQLException {
		setClob(getBindParameterIndex(parameterName), reader, length);
	}

	@Override
	public void setBlob(@Positive int parameterIndex, @Nullable InputStream inputStream, long length) throws SQLException {
		setBinaryStream(parameterIndex, inputStream, length);
	}
	@Override
	public void setBlob(@NonNull String parameterName, @Nullable InputStream inputStream, long length) throws SQLException {
		setBlob(getBindParameterIndex(parameterName), inputStream, length);
	}

	@Override
	public void setNClob(int parameterIndex, Reader reader, long length) throws SQLException {
		throw Util.unsupported("PreparedStatement.setNClob");
	}
	@Override
	public void setNClob(@NonNull String parameterName, Reader reader, long length) throws SQLException {
		setNClob(getBindParameterIndex(parameterName), reader, length);
	}

	@Override
	public void setSQLXML(@Positive int parameterIndex, @Nullable SQLXML xmlObject) throws SQLException {
		if (xmlObject == null) {
			bindNull(parameterIndex);
		} else {
			bindText(parameterIndex, xmlObject.getString());
		}
	}
	@Override
	public void setSQLXML(@NonNull String parameterName, @Nullable SQLXML xmlObject) throws SQLException {
		setSQLXML(getBindParameterIndex(parameterName), xmlObject);
	}

	@Override
	public void setObject(@Positive int parameterIndex, @Nullable Object x, int targetSqlType, int scaleOrLength) throws SQLException {
		if (x == null || targetSqlType == Types.NULL) {
			bindNull(parameterIndex);
			return;
		}
		if (Types.VARCHAR == targetSqlType) {
			if (x instanceof java.util.Date) {
				setString(parameterIndex, DateUtil.formatDate((java.util.Date) x, scaleOrLength, null));
				return;
			} else if (x instanceof Temporal) {
				setString(parameterIndex, x.toString());
				return;
			}
		} else if (Types.INTEGER == targetSqlType) {
			if (x instanceof Number) {
				setLong(parameterIndex, ((Number) x).longValue());
				return;
			} else if (x instanceof java.util.Date) {
				long unixepoch = ((java.util.Date) x).getTime();
				setLong(parameterIndex, x instanceof Date ? DateUtil.normalizeDate(unixepoch, null) : unixepoch);
				return;
			} else if (x instanceof LocalDate) {
				setLong(parameterIndex, ((LocalDate) x).toEpochDay());
				return;
			}
		} else if (Types.REAL == targetSqlType) {
			if (x instanceof Number) {
				setDouble(parameterIndex, ((Number) x).doubleValue());
				return;
			} else if (x instanceof java.util.Date) {
				long unixepoch = ((java.util.Date) x).getTime();
				setDouble(parameterIndex, DateUtil.toJulianDay(x instanceof Date ? DateUtil.normalizeDate(unixepoch, null) : unixepoch));
				return;
			}
		}
		// no conversion (targetSqlTpe and scaleOrLength are ignored)
		setObject(parameterIndex, x);
	}
	@Override
	public void setObject(@Positive int parameterIndex, @Nullable Object x, @NonNull SQLType targetSqlType, int scaleOrLength) throws SQLException {
		setObject(parameterIndex, x, targetSqlType.getVendorTypeNumber(), scaleOrLength);
	}

	@Override
	public void setObject(@NonNull String parameterName, @Nullable Object x, int targetSqlType, int scaleOrLength) throws SQLException {
		setObject(getBindParameterIndex(parameterName), x, targetSqlType, scaleOrLength);
	}
	@Override
	public void setObject(@NonNull String parameterName, @Nullable Object x, @NonNull SQLType targetSqlType, int scaleOrLength) throws SQLException {
		setObject(getBindParameterIndex(parameterName), x, targetSqlType, scaleOrLength);
	}

	@Override
	public void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException {
		throw Util.unsupported("PreparedStatement.setAsciiStream");
	}
	@Override
	public void setAsciiStream(@NonNull String parameterName, InputStream x, long length) throws SQLException {
		setAsciiStream(getBindParameterIndex(parameterName), x, length);
	}

	@Override
	public void setBinaryStream(@Positive int parameterIndex, @Nullable InputStream x, long length) throws SQLException {
		if (x == null) {
			bindNull(parameterIndex);
		} else {
			setBinaryStream(parameterIndex, x, BlobImpl.checkLength(length));
		}
	}
	@Override
	public void setBinaryStream(@NonNull String parameterName, @Nullable InputStream x, long length) throws SQLException {
		setBinaryStream(getBindParameterIndex(parameterName), x, length);
	}

	@Override
	public void setCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
		throw Util.unsupported("PreparedStatement.setCharacterStream");
	}
	@Override
	public void setCharacterStream(@NonNull String parameterName, Reader reader, long length) throws SQLException {
		setCharacterStream(getBindParameterIndex(parameterName), reader, length);
	}

	@Override
	public void setAsciiStream(int parameterIndex, InputStream x) throws SQLException {
		throw Util.unsupported("PreparedStatement.setAsciiStream");
	}
	@Override
	public void setAsciiStream(@NonNull String parameterName, InputStream x) throws SQLException {
		setAsciiStream(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setBinaryStream(@Positive int parameterIndex, @Nullable InputStream x) throws SQLException {
		setBinaryStream(parameterIndex, x, Integer.MAX_VALUE);
	}
	@Override
	public void setBinaryStream(@NonNull String parameterName, @Nullable InputStream x) throws SQLException {
		setBinaryStream(getBindParameterIndex(parameterName), x);
	}

	@Override
	public void setCharacterStream(int parameterIndex, Reader reader) throws SQLException {
		throw Util.unsupported("PreparedStatement.setCharacterStream");
	}
	@Override
	public void setCharacterStream(@NonNull String parameterName, Reader reader) throws SQLException {
		setCharacterStream(getBindParameterIndex(parameterName), reader);
	}

	@Override
	public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException {
		throw Util.unsupported("PreparedStatement.setNCharacterStream");
	}
	@Override
	public void setNCharacterStream(@NonNull String parameterName, Reader value) throws SQLException {
		setNCharacterStream(getBindParameterIndex(parameterName), value);
	}

	@Override
	public void setClob(int parameterIndex, Reader reader) throws SQLException {
		throw Util.unsupported("PreparedStatement.setClob");
	}
	@Override
	public void setClob(@NonNull String parameterName, Reader reader) throws SQLException {
		setClob(getBindParameterIndex(parameterName), reader);
	}

	@Override
	public void setBlob(@Positive int parameterIndex, @Nullable InputStream inputStream) throws SQLException {
		setBinaryStream(parameterIndex, inputStream);
	}
	@Override
	public void setBlob(@NonNull String parameterName, @Positive InputStream inputStream) throws SQLException {
		setBlob(getBindParameterIndex(parameterName), inputStream);
	}

	@Override
	public void setNClob(int parameterIndex, Reader reader) throws SQLException {
		throw Util.unsupported("PreparedStatement.setNClob");
	}
	@Override
	public void setNClob(@NonNull String parameterName, Reader reader) throws SQLException {
		setNClob(getBindParameterIndex(parameterName), reader);
	}

	@Override
	public int getParameterCount() throws SQLException {
		return getStmt().getBindParameterCount();
	}

	@Override
	public int isNullable(int param) {
		return parameterNullableUnknown;
	}

	@Override
	public boolean isSigned(int param) throws SQLException {
		throw Util.unsupported("ParameterMetaData.isSigned");
	}

	@Override
	public int getPrecision(int param) throws SQLException {
		throw Util.unsupported("ParameterMetaData.getPrecision");
	}

	@Override
	public int getScale(int param) throws SQLException {
		throw Util.unsupported("ParameterMetaData.getScale");
	}

	@Override
	public int getParameterType(int param) throws SQLException {
		throw Util.unsupported("ParameterMetaData.getParameterType");
	}

	@Override
	public String getParameterTypeName(int param) throws SQLException {
		throw Util.unsupported("ParameterMetaData.getParameterTypeName");
	}

	@Override
	public String getParameterClassName(int param) throws SQLException {
		throw Util.unsupported("ParameterMetaData.getParameterClassName");
	}

	@Override
	public int getParameterMode(int param) {
		return parameterModeIn;
	}

	private void bindNull(@Positive int parameterIndex) throws SQLException {
		if (!batching) {
			getStmt().bindNull(parameterIndex);
		}
		bind(parameterIndex, null);
	}

	private void bindInt(@Positive int parameterIndex, int x) throws SQLException {
		if (!batching) {
			getStmt().bindInt(parameterIndex, x);
		}
		bind(parameterIndex, x);
	}

	private void bindLong(@Positive int parameterIndex, long x) throws SQLException {
		if (!batching) {
			getStmt().bindLong(parameterIndex, x);
		}
		bind(parameterIndex, x);
	}

	private void bindDouble(@Positive int parameterIndex, double x) throws SQLException {
		if (!batching) {
			getStmt().bindDouble(parameterIndex, x);
		}
		bind(parameterIndex, x);
	}

	private void bindText(@Positive int parameterIndex, @Nullable String x) throws SQLException {
		if (!batching) {
			getStmt().bindText(parameterIndex, x);
		}
		bind(parameterIndex, x);
	}

	private void bindBlob(@Positive int parameterIndex, byte @NonNull [] x) throws SQLException {
		if (!batching) {
			getStmt().bindBlob(parameterIndex, x);
		}
		bind(parameterIndex, x);
	}

	private void bindZeroBlob(@Positive int parameterIndex, ZeroBlob x) throws SQLException {
		if (!batching) {
			getStmt().bindZeroblob(parameterIndex, x.n());
		}
		bind(parameterIndex, x);
	}

	private void bind(@Positive int parameterIndex, @Nullable Object x) throws SQLException {
		if (bindings == null) {
			bindings = new Object[getParameterCount()];
			bound = new boolean[bindings.length];
		}
		bindings[parameterIndex - 1] = x;
		bound[parameterIndex - 1] = true;
	}

	/*
	From JDBC Specification:
	A value must be provided for each parameter marker in the PreparedStatement object before it can be executed.
	The methods used to execute a PreparedStatement object (executeQuery, executeUpdate and execute) will throw an SQLException
	if a value is not supplied for a parameter marker.
	 */
	private void checkParameters(org.sqlite.Stmt stmt) throws SQLException {
		if (stmt.getBindParameterCount() == 0) {
			boundChecked = true;
			return;
		}
		if (bindings == null) {
			throw new StmtException(stmt, "a value must be provided for each parameter marker in the PreparedStatement object before it can be executed.", ErrCodes.WRAPPER_SPECIFIC);
		} else {
			for (boolean b : bound) {
				if (!b) {
					throw new StmtException(stmt, "a value must be provided for each parameter marker in the PreparedStatement object before it can be executed.", ErrCodes.WRAPPER_SPECIFIC);
				}
			}
			boundChecked = true;
		}
	}

	private int getBindParameterIndex(@NonNull String parameterName) throws SQLException {
		return getStmt().getBindParameterIndex(parameterName);
	}
}
